１．作成されるtxtの例を出してください。

２．作成されるテキストファイルの名前はどうなりますか?

３．作成されるテキストファイルの名前が再構成に用いたrootファイルの名前を引き継いでいると仮定して話を進めます。
ディレクトリを指定して、その中の結果のtxtファイルを読み込み、ファイル名（BASENAME_xX_yY_zZ-RUNNUMBER-XXdB～.txt）から本来の光源の位置、を読み取り、
以下のヘッダーを持つCSVファイルを作成するコードを作成してください。
x_true, y_true, z_true, x_res, x_sigma, y_res, y_sigma, z_res, z_sigma, t, t_sigma, r_sigma, d, x_diff, y_diff, z_diff
ただし、x_true, y_true, z_trueは光源の本来の位置、x_res, y_res, z_resは再構成された位置（ガウスフィットの平均値）、x_sigma, y_sigma, z_sigmaは再構成された位置の不確かさ（ガウスフィットのσ）、tは再構成された時間、t_sigmaは再構成された時間の不確かさ、r_sigmaは再構成された位置の不確かさ（3次元）、dは実際の位置と再構成された位置の距離です。x_diff, y_diff, z_diffはそれぞれx_true - x_res, y_true - y_res, z_true - z_resです。

４．これにより作成されたCSVファイルを読み込み、様々な画像を作るジュピターファイルを作成します。x軸に様々な軸にそった位置、y軸に、r_sigma, d などをとった散布図を作成したいと考えています。








keio/hkelec/reconst/reco内のコードを更新した。以下にmain.ccを示す。
```cpp
    /**
    * @file main.cc
    * @brief 光源位置再構成プログラムのメインエントリーポイント
    *
    * このプログラムは、ROOT形式の実験データを読み込み、4つのPMTの電荷・時間情報を用いて
    * 光源の位置(x,y,z)と発光時刻(t)を再構成します。
    * Minuitを使用して、観測値とモデル期待値のChi2（または尤度）を最小化します。
    *
    * @usage ./reconstructor <InputRootFile> [Options]
    *
    * @author Gemini (Modified based on user request)
    * @date 2025-01-08
    */

    #include "readData.hh"
    #include "onemPMTfit.hh"
    #include "fittinginput.hh"
    #include <TFile.h>
    #include <TTree.h>
    #include <iostream>
    #include <fstream>
    #include <string>
    #include <unistd.h>
    #include <sstream>

    /**
    * @brief 使い方とオプションの説明を表示する関数
    * 初めて使用する人向けに詳細な日本語マニュアルを表示します。
    */
    void PrintUsage(const char* progName) {
        std::cout << "======================================================================" << std::endl;
        std::cout << "  光源位置再構成プログラム (Light Source Reconstructor)" << std::endl;
        std::cout << "======================================================================" << std::endl;
        std::cout << "\n[概要]" << std::endl;
        std::cout << "  ROOTファイルのPMTヒット情報(電荷Q, 時刻T)から、光源位置(x,y,z)を推定します。" << std::endl;
        std::cout << "  TimeWalk補正、電荷依存の時間分解能、PMT半球形状を考慮したフィットを行います。" << std::endl;
        
        std::cout << "\n[使い方]" << std::endl;
        std::cout << "  " << progName << " <入力ROOTファイル> [オプション]" << std::endl;
        
        std::cout << "\n[オプション]" << std::endl;
        std::cout << "  -u <0/1>   : 3本ヒット救済モード (デフォルト: 0=OFF)" << std::endl;
        std::cout << "      1 : 3本ヒット時、残り1本を電荷0のヒットとして扱い4本分で計算" << std::endl;

        std::cout << "  -m <model> : 電荷期待値モデル (デフォルト: func_f)" << std::endl;
        std::cout << "      func_f : r=28.5cm, mu = A * c0 * (1 - sqrt(1 - (28.5/r)^2)) * eps" << std::endl;
        std::cout << "      func_g : r=23.5cm, mu = A * c0 / r^2 * eps" << std::endl;
        std::cout << "               ※ 係数c0, eps(角度依存)は fittinginput.hh で設定" << std::endl;

        std::cout << "  -q <model> : 電荷Chi2定義 (デフォルト: gaus)" << std::endl;
        std::cout << "      gaus : Gaussian" << std::endl;
        std::cout << "      bc   : Baker-Cousins (Poisson分布に基づく尤度比)" << std::endl;
        std::cout << "      none : 電荷情報を使用しない (時間のみでフィット)" << std::endl;

        std::cout << "  -t <model> : 時間Chi2定義 (デフォルト: gaus)" << std::endl;
        std::cout << "      gaus     : Gaussian (sigmaは電荷依存)" << std::endl;
        std::cout << "      goodness : SK風Goodness" << std::endl;
        std::cout << "      emg      : EMG分布 (現在は試験的実装)" << std::endl;
        std::cout << "      none     : 時間情報を使用しない (電荷のみでフィット)" << std::endl;
        
        std::cout << "\n[出力]" << std::endl;
        std::cout << "  入力ファイル名にオプションに応じたサフィックスを付与して出力します。" << std::endl;
        std::cout << "  例: run01_reconst_3hits_bc_func_f_goodness.root" << std::endl;
        std::cout << "  run01_reconst_3hits_bc_func_f_goodness.csv" << std::endl;
        std::cout << "  CSV出力列: fit_x,fit_y,fit_z,t_light,err_x,err_y,err_z,err_t,chi2,ndf,A,B,status" << std::endl;
        std::cout << "  ※計算に使用しなかったパラメータは -9999 が出力されます。" << std::endl;
        
        std::cout << "\n[設定]" << std::endl;
        std::cout << "  TimeWalk係数やSigma係数、ジオメトリ等は 'fittinginput.hh' で定義されています。" << std::endl;
    
        std::cout << "\n[必要なもの]" << std::endl;
        std::cout << "  - ROOT形式の入力データファイル" << std::endl;
        std::cout << "  - ペデスタル平均値ファイル 'hkelec_pedestal_hithist_means.txt' が同じディレクトリに必要です。" << std::endl;
        std::cout << "    （入力ROOTファイルと同じディレクトリを指します）" << std::endl;

        std::cout << "======================================================================" << std::endl;
    }

    int main(int argc, char** argv) {
        FitConfig config;
        int opt;
        std::string inputBinFile;
        
        // オプション解析
        while ((opt = getopt(argc, argv, "u:m:q:t:h")) != -1) {
            switch (opt) {
                case 'u': config.useUnhit = (std::stoi(optarg) == 1); break;
                case 'm':
                    if (std::string(optarg) == "func_g") config.chargeModel = ChargeModelType::FuncG;
                    else config.chargeModel = ChargeModelType::FuncF;
                    break;
                case 'q':
                    if (std::string(optarg) == "bc") config.chargeType = ChargeChi2Type::BakerCousins;
                    else if (std::string(optarg) == "none") config.chargeType = ChargeChi2Type::None;
                    else config.chargeType = ChargeChi2Type::Gaussian;
                    break;
                case 't':
                    if (std::string(optarg) == "goodness") config.timeType = TimeChi2Type::Goodness;
                    else if (std::string(optarg) == "emg") config.timeType = TimeChi2Type::EMG;
                    else if (std::string(optarg) == "none") config.timeType = TimeChi2Type::None;
                    else config.timeType = TimeChi2Type::Gaussian;
                    break;
                case 'h':
                    PrintUsage(argv[0]);
                    return 0;
                default:
                    PrintUsage(argv[0]);
                    return 1;
            }
        }

        if (optind >= argc) {
            std::cerr << "エラー: 入力ファイルが指定されていません。\n" << std::endl;
            PrintUsage(argv[0]);
            return 1;
        }
        inputBinFile = argv[optind];

        // ファイル名生成ロジック
        std::string dirPath = "./";
        std::string baseName = inputBinFile;
        size_t lastSlash = inputBinFile.find_last_of("/");
        if (lastSlash != std::string::npos) {
            dirPath = inputBinFile.substr(0, lastSlash + 1);
            baseName = inputBinFile.substr(lastSlash + 1);
        }
        size_t lastDot = baseName.find_last_of(".");
        if (lastDot != std::string::npos) baseName = baseName.substr(0, lastDot);
        std::string suffixToRemove = "_eventhist";
        size_t pos = baseName.find(suffixToRemove);
        if (pos != std::string::npos) baseName.replace(pos, suffixToRemove.length(), "");

        // サフィックス生成
        std::stringstream ss;
        ss << "_reconst";
        if (config.useUnhit) ss << "_3hits"; else ss << "_4hits";
        
        // 電荷Chi2 Suffix
        if (config.chargeType == ChargeChi2Type::BakerCousins) ss << "_bc";
        else if (config.chargeType == ChargeChi2Type::None) ss << "_noQ";
        else ss << "_gausQ";

        // 電荷モデル Suffix
        if (config.chargeType != ChargeChi2Type::None) {
            if (config.chargeModel == ChargeModelType::FuncG) ss << "_func_g";
            else ss << "_func_f";
        }

        // 時間Chi2 Suffix
        if (config.timeType == TimeChi2Type::EMG) ss << "_emg";
        else if (config.timeType == TimeChi2Type::Goodness) ss << "_goodness";
        else if (config.timeType == TimeChi2Type::None) ss << "_noT";
        else ss << "_gausT";

        // 出力ファイル名生成
        std::string outputRootFile = dirPath + baseName + ss.str() + ".root";
        std::string outputCsvFile = dirPath + baseName + ss.str() + ".csv";

        // 実行開始表示
        std::cout << "------------------------------------------------" << std::endl;
        std::cout << "解析を開始します: " << inputBinFile << std::endl;
        std::cout << "出力ファイル: " << outputRootFile << std::endl;
        std::cout << "モデル設定: Charge=" << (int)config.chargeType 
                << ", Model=" << (int)config.chargeModel 
                << ", Time=" << (int)config.timeType << std::endl;
        std::cout << "------------------------------------------------" << std::endl;

        // ペデスタル読み込み
        std::string pedestalFile = dirPath + "hkelec_pedestal_hithist_means.txt";
        std::map<int, PedestalData> pedMap;
        if (readPedestals(pedestalFile, pedMap) != 0) {
            std::cerr << "警告: ペデスタルファイルが見つかりません (" << pedestalFile << ")" << std::endl;
            return 1;
        }

        // データリーダー初期化
        DataReader reader(inputBinFile, pedMap);
        
        // 出力ファイル初期化
        TFile *fOut = new TFile(outputRootFile.c_str(), "RECREATE");
        TTree *tOut = new TTree("fit_results", "Fit Results");
        FitResult res;
        
        // ブランチ設定
        tOut->Branch("fit_x", &res.x, "fit_x/D");
        tOut->Branch("fit_y", &res.y, "fit_y/D");
        tOut->Branch("fit_z", &res.z, "fit_z/D");
        tOut->Branch("t_light", &res.t, "t_light/D");
        tOut->Branch("chi2", &res.chi2, "chi2/D");
        tOut->Branch("ndf", &res.ndf, "ndf/I");
        tOut->Branch("A", &res.A, "A/D");
        tOut->Branch("B", &res.B, "B/D");
        tOut->Branch("status", &res.status, "status/I");

        std::ofstream ofs(outputCsvFile.c_str());
        ofs << "fit_x,fit_y,fit_z,t_light,err_x,err_y,err_z,err_t,chi2,ndf,A,B,status\n";

        // フィッター初期化
        LightSourceFitter fitter;
        fitter.SetConfig(config);

        // データループ
        std::vector<PMTData> eventHits;
        int n_total = 0;
        int n_success = 0;

        while (reader.nextEvent(eventHits)) {
            n_total++;

            if (config.useUnhit) {
                if (eventHits.size() < 3) continue;
                if (eventHits.size() == 3) {
                    // 欠損CHをUnhit(0)として追加
                    bool hitFlags[4] = {false, false, false, false};
                    int eventID = eventHits[0].eventID;
                    for (const auto& hit : eventHits) hitFlags[hit.ch] = true;
                    for (int ch = 0; ch < 4; ++ch) {
                        if (!hitFlags[ch]) {
                            PMTData unhitData;
                            unhitData.eventID = eventID;
                            unhitData.ch = ch;
                            unhitData.charge = 0.0;
                            unhitData.time = -9999.0;
                            unhitData.isHit = false;
                            unhitData.x = PMT_POSITIONS[ch][0]; 
                            unhitData.y = PMT_POSITIONS[ch][1];
                            unhitData.z = PMT_POSITIONS[ch][2];
                            eventHits.push_back(unhitData);
                            break;
                        }
                    }
                }
            } else {
                if (eventHits.size() < 4) continue;
            }

            if (fitter.FitEvent(eventHits, res)) {
                // 未計算値のマスク処理 (-9999)
                if (config.chargeType == ChargeChi2Type::None) {
                    res.A = -9999;
                    res.B = -9999;
                } else {
                    // ChargeFit有効時: Bは今回のモデルで存在しないため -9999 に設定
                    if (config.chargeModel == ChargeModelType::FuncF || config.chargeModel == ChargeModelType::FuncG) {
                        res.B = -9999;
                    }
                }
                
                if (config.timeType == TimeChi2Type::None) {
                    res.t = -9999;
                    res.err_t = -9999;
                }

                tOut->Fill();
                ofs << res.x << "," << res.y << "," << res.z << "," << res.t << ","
                    << res.err_x << "," << res.err_y << "," << res.err_z << "," << res.err_t << ","
                    << res.chi2 << "," << res.ndf << "," << res.A << "," << res.B << "," << res.status << "\n";
                n_success++;
            }
            
            if (n_total % 1000 == 0) std::cout << "処理中... " << n_total << " events" << std::endl;
        }

        tOut->Write();
        fOut->Close();
        ofs.close();
        
        std::cout << "完了: 全" << n_total << "イベント中、" << n_success << "イベントが収束しました。" << std::endl;

        return 0;
    }
```

更新に伴い、コードの修正、作成を依頼したい
出力されるCSVファイルは以下のようなファイル名になる
LDhkelec_x0_y0_z162-001-15.00dB_reconst_3hits_bc_func_f_gausT.csv
(BASENAME_xX_yY_zZ-RUNNUMBER-(XXdB)_reconst_(?hits)_(charge distribution)_(modeltype)_(time distribution).csv)
3hits_bc_func_f_goodnessの部分はそれぞれmainを実行する際のオプションに対応したものとなる
また出力されるCSVファイルの冒頭は以下のようになる。

    fit_x,fit_y,fit_z,t_light,err_x,err_y,err_z,err_t,chi2,ndf,A,B,status
    -4.47075,-13.6813,5.85835e-05,2.53673,3.04151,3.77734,236.677,0.294307,1.80992,3,0.418138,-9999,3
    -4.22924,4.44598,10.4194,3.06123,6.92714,3.06145,36.5339,0.90077,2.96824,3,0.343804,-9999,3
    0.0298712,4.12584,2.18881,2.7699,4.05233,3.81332,62.2008,0.631147,1.69962,3,0.460084,-9999,3
    4.58633,0.971374,27.5397,3.27118,2.33636,2.18586,3.04071,0.29927,1.51982,3,0.319778,-9999,3
    0.506416,-4.99929,21.8043,3.25475,2.61105,2.76138,5.09731,0.319508,7.42249,3,0.301983,-9999,3
    -2.95854,6.49623,1.57625e-07,2.65563,3.73262,3.83433,18.4986,0.301862,3.42808,3,0.368809,-9999,3
    -1.84643,-2.59865,30.2967,3.29376,2.32477,2.31851,2.11807,0.305112,2.4577,3,0.305063,-9999,3

そちらでmain.ccやonemPMTfit.ccを確認すればわかることだが、これらのコードはオプションを持ち、オプションに対応したファイル名になるほか、出力されるCSVでは、オプションによってはそもそも計算されない値が-9999となる。

さて本題に入るが、batch_analysis.pyを修正して、今までのt,x,y,zに加えて、Aについてもグラフの作成とガウスフィットを行い、フィット結果をテキストファイルに出すようにしたい。
この際、対応する列が-9999だった場合、すなわちそもそも計算していない場合は、グラフは作成せず、フィット結果のテキストファイルにはそもそも計算していないことを書くようにしたい。
また、これに伴い、aggregate_results.pyも修正したい。
現在、テキストファイルからはx,y,z,t,そのシグマ、rのシグマなどを取り出していると思うが、Aのガウスフィットの平均とそのシグマも取り出すようにしてください。
また、取り出せなかった際は、出力するcsvの対応する値を-9999にしてください。

さらに、現在ファイル名から真のxyz を取り出していると思いますが、それに加えて、再構成方法も取り出すようにしてください。すなわち出力に以下の4列を追加します。
hits:3hitsなら3、4hitsなら4
qdist: bc，noQなど、テキストファイルのサフィックスを抽出
q_mu_model: func_fなど、サフィックスを抽出。qdistがnoQの時はnoneとする。この時、ファイル名のサフィックスの数が減ることに注意
tdist: gausTなど、サフィックスを抽出
作成されたCSVを解析する際にこれらのサフィックスで条件をかけることがあると思います。
また、ファイル名からdBの情報も取り出し、出力CSVにattenuation_dB列を追加してください。

さらに、真の相対光量も計算して、出力の列に真の相対光量および、相対光量のフィット結果(A)との差の列を追加したいです。真の相対光量は以下のようにして計算できます。
以下のようなCSVファイル(引数でパスを指定する)が存在します。

    Attenuation_dB,Device,PDvolt_mean,PDvolt_std,ReadOutBoard,RunId,RunLength,RunMode,TimeStamp,TriggerChannel
    15,digitizer,5.026111111,0.0061864,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-10_y35_z127-001-15.00dB,12,HitOnly,2025-12-26T17:11:13.647446,4
    20,digitizer,5.0175,0.006178089,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-10_y35_z127-002-20.00dB,12,HitOnly,2025-12-26T17:11:37.733725,4
    15,digitizer,5.013888889,0.002357022,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-10_y35_z162-001-15.00dB,12,HitOnly,2025-12-26T19:11:15.296829,4
    20,digitizer,5.020744444,0.008037978,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-10_y35_z162-002-20.00dB,12,HitOnly,2025-12-26T19:11:34.333441,4
    15,digitizer,5.004444444,0.004006167,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y0_z127-001-15.00dB,12,HitOnly,2025-12-26T21:07:11.861175,4
    20,digitizer,5.006111111,0.005844344,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y0_z127-002-20.00dB,12,HitOnly,2025-12-26T21:07:38.916677,4
    15,digitizer,5.0137,0.009251844,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y0_z162-001-15.00dB,12,HitOnly,2025-12-26T20:24:43.986608,4
    20,digitizer,5.001666667,0.005499722,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y0_z162-002-20.00dB,12,HitOnly,2025-12-26T20:25:03.060589,4
    15,digitizer,5.023333333,0.007777778,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y35_z127-001-15.00dB,12,HitOnly,2025-12-26T17:15:10.989780,4
    20,digitizer,5.016111111,0.019641889,kc705,/home/hkpd/hkelec/DiscreteSoftware/data/20251226kishita/LDhkelec_x-20_y35_z127-002-20.00dB,12,HitOnly,2025-12-26T17:15:31.024828,4

これのファイル名の列のベースネームを対応させ、PDの電圧が5 V, 15dBの減衰量、の場合のAを1として、相対的な真の光量を計算してください。
以下に似たようなことを行なっているコードを添付します。

以上について、曖昧な点、仕様などがありましたら、勝手に推測せず私に質問してください。
特に、aggregate_results.pyで出力されるCSVファイルの列の内容の確認は必ず行いたいです。
