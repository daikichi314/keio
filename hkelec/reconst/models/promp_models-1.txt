x=r,y=charge/light_powerのグラフを、pmt_num=1,x=-35,y=35の条件のもとプロットしたい。

では改めて、PMT1~4について、セル2で行ったような処理（条件付きでグラフを描写した後フィッティング）を行ってください。
ただし、PMT_num=1,2,3,4はそれぞれ、
(x,y)=(-35,35),(35,35),(-35,-35),(35,-35)
に対応しています。
何か不明な点があれば勝手に推測せず私に聞いてください。

1つのセルでよいです。また、フィット結果を最後にまとめて表示してください。
グラフはそれぞれ別々に表示した後に2*2のまとめた図もだしてください
初期値はすべて、c0=0, c1= 1600にしてください。


出力するCSVの仕様について、追加でグラフにフィッティングに反映するかどうかのフラグを追加してください。デフォルトは反映するようにしてください。
もとのグラフをこちらで観察して、外れ値だと思ったものはここで描写しないようにこちらで変更します。
そして、plot_from_csv.Cの方では、すべての点を描写はするものの、外れ値と判定されたものはフィッティングには反映しないようにし、色などをほかの点と変えて区別がつくようにしてください。

１．y = c0 + c1 * (1 - sqrt(1 - (32.5/r_from_center)^2))
によるのフィットについて、これはCharge_errを考慮していないと思います。せっかく算出しているのだから、エラーバーとして表示し、フィッティングに反映させることはできないでしょうか。
２．このジュピターファイルは、以下の電荷の期待値モデルのf(r_i),\epsilon(cos(\alpha_i))を決定することを目的としています。
Q_i^exp(A,r_i,\alpha_i) = A * f(r_i) * \epsilon(cos(\alpha_i))
ここで、QはCharge、iはPMT_num、Aはlight_powerに対応しており、r_i,\alpha_iは、csvのiごとのr_from_center,\alpha_from_centerの値です。
各PMTでのフィット結果に基づいて、いま、
f(r_i)=c0 + c1 * (1 - sqrt(1 - (32.5/r_from_center)^2))が決定していると思うので、PMTごとの関数にフィット結果を代入してこの関数を作ってください。
３．もとのCSVについて、それぞれのPMT上((x,y)=(+-35,+-35)をみたす)の各点の結果について、
x=light_power,y=chargeのグラフを作成してください。また、それぞれ直線でフィットしてください。2点しかないので2点を通る線を引ければそれでよいです。
PMTごとにグラフはまとめてください（各8枚あるはずです。）
これは、そもそもQとAが比例関係にあることを確認するためです。

以上について、何か不明な点があれば、質問してください。



１．Charge_err(pC)という列があるはずです。
２．PMTごとに違う値になると思うので、PMTごとに関数を作ってください。
３．4箇所：(-35,35), (35,35), (-35,-35), (35,-35)）について、それぞれz=87,97,...,157,162の9点（8点ではありませんでした）が恐らく存在するので、もしあれば、それぞれの点でlight_power vs Chargeのグラフをつくってください。ただし、(-35,35)上ではPMT_num=1、(35,35)上ではPMT_num=2、(-35,-35)上ではPMT_num=3、(35,-35)上ではPMT_num=4のデータのみを使ってください。
恐らく、各点で2点ずつデータが存在するはずです。

まだ不明な点があれば質問してください。


QとAが比例することを確かめるため、以下を行います。
PMTi上の点(+-35,+-35,z)について、r_from_centerから、先ほど決めたf_i(r_i)を用いて、
Charge_i/f_i(r_i)を計算し、y軸に、x軸にlight_powerをとってプロットしたグラフをPMTごとに作成してください。
また、直線でフィットして、原点を通っているかわかるようにx=0~1で描写してください。
できればCharge<20の点は外れ値として除外してください。
質問があればしてください。





では、最後の仕上げとして、元のデータフレーム内のPMT_num=iのすべてのデータについて、
Charge/(light_power*f_i(r_from_center))を計算し、y軸に、x軸にcos(\alpha_from_center)をとってプロットしたグラフをiごとに作成してください。 

何か不明な点があれば勝手に推測せず私に聞いてください。






実数の引数r_pmt,dfが与えられたとき、以下の処理を行う関数を作成してください。ただし、dfは、以下の列が存在しています。#PMT_num  Charge(pC)  Charge_err(pC)  light_power(def:(15dB, 5V)=1)  attenuation_db  pd_volt  x   y  z  r  cos(alpha) r_from_center  cos(alpha_from_center)

    １．いま、PMTという装置が、部屋の床の中心を原点とし、Z軸を鉛直上向きに取った座標系の(x,y)=(+-35,+-35)に4つ位置しています（#PMT_num=1,2,3,4がそれぞれ、(-35,35),(35,35),(-35,-35),(35,-35)(cm)に対応し、それぞれのPMTでの観測結果や光源との関係、光源の位置などがdfにまとめられている）。これらは半球のような形状をしていますが、その中心のz座標として妥当な値が分かっておらず、これを調べたいです。また、dfのx,y,zは、それぞれのイベントにおける、光源の位置を示しています。r  cos(alpha) r_from_center  cos(alpha_from_center)は仮の中心からみた光源の天頂角や距離などで、今回は使わないです。まずこれらの列を削除してください。
    ２．r_pmtはPMTの半径の値であり、PMTの表面のz座標の値=80.5 (cm) からrを引くことで、中心のz座標を定義できます。まず、dfに、その中心(+-35,+-35,80.5-r)（符号はPMTの番号による。#PMT_numは今後iで表現することにする）から光源(x,y,z)までの距離rおよび、天頂角cos(alpha)（真上にあるとき、cos(alpha)=1となる）を追加してください。
    ３．PMTごとに(iごとに)、cos(alpha)=1の点(実数で計算すると=1にはならないかもしれないのでわずかな幅を持たせるか、光源の位置が(+-35,+-35)の点を探してくるかする)となるデータについて、縦軸にCharge(pC)/light_power、横軸にrを取った散布図を作成してください。また、Charge_err(pC)/light_powerも計算し、エラーバーとして表示して下さい。
    なお、Charge/light_powerが20以下の点は除外してください。
    ４．作成したグラフを、以下の関数f_i(r)およびg_i(r)でそれぞれフィッティングして、フィット結果(パラメタの値、その誤差、chi2/ndf、その他有用な情報があれば)を表として出力してください。
    f_i(r)=c0*(1-sqrt(1-(r_pmt/r)^2))
    g_i(r)=c0/r^2
    また、フィット結果から、PMTごとにf_i(r), g_i(r)を定義してください。今後の解析で利用したいです。
    ５．グラフを作成する際は、1枚ずつのグラフを4枚と、4つのグラフが1つにまとまったものを1枚作成して下さい。
    ６．できた関数を利用して、r vs chi2/ndfのグラフをPMTごとに描き、chi2/ndfの合計が最小となるrを取得したいと考えています。


    以上について、仕様についてあいまいな点や必要な情報、不足している情報などがあれば、勝手に推測せず、私に質問して下さい。



    １．r_pmtは10~60程度で調べたいです。
    ＞つまり、r_pmtを変化させながらフィットを繰り返し、最適なr_pmt（=PMTの半径）を探すという理解で正しいでしょうか？
    そうです。私が間違えました。r_pmtが正しいです。
    ２．Aの閾値を設定する法補でお願いいたします。
    ３．rの範囲はおおよそ40~110程度になるとは思いますが(r_pmtにもよる)、存在するデータ点に合わせて適切に設定してください。
    なお、言い忘れていましたが、せっかくCharge/light_powerの誤差を計算するのですから、フィッティング時には誤差を考慮に入れてください。ROOTならできることなのでPythonでもできると思ってお願いしているのですが、無理ならやらなくていいです。
    ４．現在のノートブックにdfを定義してあるので、ここに作ってください。
    ５．#PMT_num=1,2,3,4がそれぞれ、(x,y)=(-35,35),(35,35),(-35,-35),(35,-35)(cm)に対応していると先ほど述べました。また、チャットのコンテキストにdf.head()の結果を添付しました。
    ６．軸ラベルは、横軸はr_light source to PMT center [cm]、縦軸はCharge [cm] / light_power(=1 when (15dB, 5V)=1)としてください。タイトルには、r_pmt=???とPMTの番号の情報を含める他、卒業論文に載せる図として何か他にあったらわかりやすいじょうほうがあればいれてください。
    まとめたグラフは2*2でよいです。

    追加の質問があれば遠慮なくいってください。あいまいな点を勝手に推測されるのが一番困ります。



    １．0.99にしましょう。
    ２．pCが正しいです。cmは私のミスです。
    ３．それでいいです。
    ４．0.5 cm刻みでやってください。そのかわり、範囲は10~45に変更しましょう。
    ５．両方の結果を比較して、よりchi2/ndfの合計を小さくできる方をその後の解析に使いたいと考えています。

    これ以外にあいまいな点はもうないでしょうか。



    １．グラフ作成の関数と最適なr_pmtの探索は分けて行います。はじめにのべたように、r_pmt,dfを入力とする関数を作るわけですから、作成した関数になんらかの入力を入れた際に、その値に対応したグラフの作成、フィッティング、フィット結果の表示といった一連の処理を行うものだと思います。もちろん、最適なr_pmtが見つかった後に、その最適値を入力として、関数を実行してもらっても構いません。

    ２．グラフの作成等を行う関数は引数としたr_pmtによる解析を行いますので、当然それに依存したフィットパラメータが得られると思いますが、毎回関数が実行されるたびに、対応したf,gが定義できると思うのでそれを行ってください。もちろん、最後に最適な最適値を入力として関数を実行することで最適なf,gを決めていただいても構いません。

    これ以外にあいまいな点はもうないでしょうか。



    find_optimal_r_pmtについて、
    １．現在すべてのr_pmtの値について、画像を作成しているようですが、これは必要ないです。
    ２．最適なr_pmtの探索の方法ですが、現在はfの曲線とgの曲線を足し合わせてその最小値を出していますが、そうではなくて、fの曲線の足し合わせの最小値とgの曲線の足し合わせの最小値をそれぞれ得たいのです。つまり、fの場合の最適地とgの場合の最適地は別々の値になります。少し考えればわかると思います。

    質問はありますか?



最適なr_pmtに対するfit_functions_f, fit_functions_gを定義するところまで行ったので次に進みたいです。

データフレーム内のPMT_num=iのすべてのデータについて、
Charge/(light_power*f_i(r))およびCharge/(light_power*g_i(r))を計算し、y軸に、x軸にcos(alpha)をとってプロットしたグラフをiごとに作成してください。 

何か不明な点があれば勝手に推測せず私に聞いてください。
また、とりあえずはすべての点をプロットすればよいですが、後々プロってする点の条件を追加したいです。(例えばCharge>5の点のみをプロットするなど。できればコメントアウトしておいて)



では、次のセルで、同様のプロット(条件付き)をそれぞれ行ったのち、これを以下の7次多項式で近似したい。
epsilon(cos(alpha))=c0+c1*cos(alpha)+...+c7*cos^7(alpha)
このとき、できればcos(alpha)=1の時にepsilon(cos(alpha))=1となるように制限をかけたい。やり方を相談したい。
一応Charge_err/(light_power*f_i(r))およびCharge_err/(light_power*g_i(r))を計算できるはずなので、これを誤差として、フィッティングにも反映したい。
それぞれのフィット結果（各パラメタとその誤差、chi2/ndfなど）を最後に表に出してください。

何か質問はありますか?